{"version":3,"sources":["../../src/relay/init-relay.js"],"names":["ROOT_PATH","schemaPath","resolve","reject","startsWith","join","existsSync","msg","Error","isJson","endsWith","dir","dirname","file","basename","jsonPath","global","__relayPluginSchemaJsonPath","require"],"mappings":";;;;;;AAAA;;;;AACA;;;;AACA;;;;AACA;;;;AACA;;;;;;AAEA,IAAMA,YAAY,4BAAlB;;AAGA;;;;;;;;;;kBASe,UAACC,UAAD;AAAA,WAAgB,uBAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AAC9D,kDAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AACC;AACAF,yCAAaA,WAAWG,UAAX,CAAsB,GAAtB,IACP,eAAOC,IAAP,CAAYL,SAAZ,EAAuBC,UAAvB,CADO,GAEPA,UAFN;;AAIA;;AAND,gCAOM,kBAAGK,UAAH,CAAcL,UAAd,CAPN;AAAA;AAAA;AAAA;;AAQSM,+BART,0CAQoDN,UARpD;;AASGE,mCAAO,IAAIK,KAAJ,CAAUD,GAAV,CAAP;AATH;;AAAA;;AAaC;AACME,kCAdP,GAcgBR,WAAWS,QAAX,CAAoB,OAApB,CAdhB;AAeOC,+BAfP,GAea,eAAOC,OAAP,CAAeX,UAAf,CAfb;AAgBOY,gCAhBP,GAgBc,eAAOC,QAAP,CAAgBb,UAAhB,EAA4BQ,SAAS,OAAT,GAAmB,KAA/C,CAhBd;AAiBOM,oCAjBP,GAiBkB,eAAOV,IAAP,CAAYM,GAAZ,EAAqBE,IAArB,WAjBlB;;AAmBC;;AAnBD,kCAoBK,CAACJ,MAAD,IAAW,CAAC,kBAAGH,UAAH,CAAcS,QAAd,CApBjB;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA,mCAsBW,4BAAad,UAAb,EAAyBU,GAAzB,EAA8BE,IAA9B,CAtBX;;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAwBKV;AAxBL;;AAAA;;AA6BC;;AAEA;AACA;AACA;AACA;AACA;AACAa,mCAAOC,2BAAP,GAAqCF,QAArC;AACAG,oCAAQ,sBAAR;;AAEA;AACAhB,oCAAQ,EAAEa,kBAAF,EAAR;;AAxCD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,SAAD;AA0CD,KA3C8B,CAAhB;AAAA,C","file":"init-relay.js","sourcesContent":["import Promise from 'bluebird';\r\nimport fs from 'fs-extra';\r\nimport fsPath from 'path';\r\nimport updateSchema from './update-schema';\r\nimport { rootModulePath } from '../server/paths';\r\n\r\nconst ROOT_PATH = rootModulePath();\r\n\r\n\r\n/**\r\n * Initializes Relay, ensuring the GraphQL [schema.json] exists and\r\n * the relay-babel plugin has access to it.\r\n *\r\n * @param {String} schemaPath:  The absolute path to the GraphQL\r\n *                              `schema.js` or `schema.json` file.\r\n *\r\n * @return {Promise}.\r\n */\r\nexport default (schemaPath) => new Promise((resolve, reject) => {\r\n  (async () => {\r\n    // Resolve to an absolute path.\r\n    schemaPath = schemaPath.startsWith('.')\r\n        ? fsPath.join(ROOT_PATH, schemaPath)\r\n        : schemaPath;\r\n\r\n    // Ensure the schema exists.\r\n    if (!fs.existsSync(schemaPath)) {\r\n      const msg = `The GraphQL JS schema file path '${ schemaPath }' does not exist.`;\r\n      reject(new Error(msg));\r\n      return;\r\n    }\r\n\r\n    // Extract path information.\r\n    const isJson = schemaPath.endsWith('.json');\r\n    const dir = fsPath.dirname(schemaPath);\r\n    const file = fsPath.basename(schemaPath, isJson ? '.json' : '.js');\r\n    const jsonPath = fsPath.join(dir, `${ file }.json`);\r\n\r\n    // Ensure the [schema.json] exists.\r\n    if (!isJson && !fs.existsSync(jsonPath)) {\r\n      try {\r\n        await updateSchema(schemaPath, dir, file);\r\n      } catch (err) {\r\n        reject(err);\r\n        return;\r\n      }\r\n    }\r\n\r\n    // Initialize the plugin with the path to the [schema.json].\r\n\r\n    // HACK:  Store the path to the GraphQL Schema in a global variable.\r\n    //        This is so the path can be dynamically set for the `babel-relay-plugin`\r\n    //        and not hard-coded, which is the only way the Realy samples show how this works.\r\n    //        There is no apparent way to pass an actual instance of the `babel-relay-plugin`\r\n    //        (with the schema path dynamically set) into the WebPack babel-loader.\r\n    global.__relayPluginSchemaJsonPath = jsonPath;\r\n    require('./babel-relay-plugin');\r\n\r\n    // Finish up.\r\n    resolve({ jsonPath });\r\n  })();\r\n});\r\n"]}