{"version":3,"sources":["../../src/relay/update-schema.js"],"names":["schemaPath","outputDir","outputFile","Promise","resolve","reject","Error","paths","json","graphql","existsSync","Schema","require","jsonResult","errors","error","outputFileSync","JSON","stringify"],"mappings":";;;;;;AAAA;;;;AACA;;AACA;;AACA;;;;;;AAIA;;;;;;;;;;;;kBAYe,UAACA,UAAD,EAAaC,SAAb;AAAA,MAAwBC,UAAxB,uEAAqC,QAArC;AAAA,SAAkD,IAAIC,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;;AAEhG;AACA,QAAI,mBAAQJ,SAAR,CAAJ,EAAwB;AACtBI,aAAO,IAAIC,KAAJ,CAAU,uCAAV,CAAP;AACA;AACD;AACD,QAAMC,QAAQ;AACZC,YAAUP,SAAV,SAAyBC,UAAzB,UADY;AAEZO,eAAaR,SAAb,SAA4BC,UAA5B;AAFY,KAAd;;AAKA;AACA,QAAI,CAAC,kBAAGQ,UAAH,CAAcV,UAAd,CAAL,EAAgC;AAC9BK,aAAO,IAAIC,KAAJ,6BAAoCN,UAApC,wBAAP;AACA;AACD;AACD,QAAMW,SAASC,QAAQZ,UAAR,EAAoBW,MAAnC;AACA,QAAI,EAAEA,wCAAF,CAAJ,EAAwC;AACtCN,aACE,IAAIC,KAAJ,+BAAsCN,UAAtC,oCADF;AAGA;AACD;;AAED,8CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,qBAE2B,sBAAQW,MAAR,gCAF3B;;AAAA;AAEOE,wBAFP;;AAAA,mBAGKA,WAAWC,MAHhB;AAAA;AAAA;AAAA;;AAISC,mBAJT,GAIiB,IAAIT,KAAJ,CAAU,oCAAV,CAJjB;;AAKGS,oBAAMD,MAAN,GAAeD,WAAWC,MAA1B;AACAT,qBAAOU,KAAP;AANH;;AAAA;AASC,gCAAGC,cAAH,CACET,MAAMC,IADR,EAEES,KAAKC,SAAL,CAAeL,UAAf,EAA2B,IAA3B,EAAiC,CAAjC,CAFF;;AAKA;AACA,gCAAGG,cAAH,CAAkBT,MAAME,OAAxB,EAAiC,4BAAYE,MAAZ,CAAjC;;AAEA;AACAP,sBAAQ,EAAEG,YAAF,EAAR;;AAlBD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAD;AAoBD,GA7CgE,CAAlD;AAAA,C","file":"update-schema.js","sourcesContent":["import fs from 'fs-extra';\r\nimport { isBlank } from 'js-util/lib/util';\r\nimport { graphql, GraphQLSchema } from 'graphql';\r\nimport { introspectionQuery, printSchema } from 'graphql/utilities';\r\n\r\n\r\n\r\n/**\r\n * Updates the schema at the given path.\r\n *\r\n * @param {String} schemaPath: The absolute path to the schema JS file to build.\r\n *                             The file must export a { Schema } field.\r\n *\r\n * @param {String} outputDir: The absolute directory to save the file to.\r\n *\r\n * @param {String} outputFile: The name of the files (.json and .graphql) to wirte.\r\n *                             Default: 'schema'.\r\n *\r\n */\r\nexport default (schemaPath, outputDir, outputFile = 'schema') => new Promise((resolve, reject) => {\r\n\r\n  // Setup initial conditions.\r\n  if (isBlank(outputDir)) {\r\n    reject(new Error('An output directory was not specified'));\r\n    return;\r\n  }\r\n  const paths = {\r\n    json: `${ outputDir }/${ outputFile }.json`,\r\n    graphql: `${ outputDir }/${ outputFile }.graphql`,\r\n  };\r\n\r\n  // Ensure the schema exists.\r\n  if (!fs.existsSync(schemaPath)) {\r\n    reject(new Error(`A schema at the path '${ schemaPath }' does not exist.`));\r\n    return;\r\n  }\r\n  const Schema = require(schemaPath).Schema;\r\n  if (!(Schema instanceof GraphQLSchema)) {\r\n    reject(\r\n      new Error(`The module at the path '${ schemaPath }' does not expose a {Schema}.`)\r\n    );\r\n    return;\r\n  }\r\n\r\n  (async () => {\r\n    // Save JSON of full schema introspection for Babel Relay Plugin to use.\r\n    const jsonResult = await (graphql(Schema, introspectionQuery));\r\n    if (jsonResult.errors) {\r\n      const error = new Error('Failed while introspecting schema.');\r\n      error.errors = jsonResult.errors;\r\n      reject(error);\r\n      return;\r\n    }\r\n    fs.outputFileSync(\r\n      paths.json,\r\n      JSON.stringify(jsonResult, null, 2)\r\n    );\r\n\r\n    // Save user readable type system shorthand of schema.\r\n    fs.outputFileSync(paths.graphql, printSchema(Schema));\r\n\r\n    // Finish up.\r\n    resolve({ paths });\r\n  })();\r\n});\r\n"]}