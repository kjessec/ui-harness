{"version":3,"sources":["../../src/server/paths.js"],"names":["rootModulePath","parent","resolve","basename","ROOT_PATH","closestModulePath","moduleDir","moduleName","dir","join","existsSync","undefined","REACT_PATH","__dirname","trimRootModulePath","path","is","String","startsWith","substr","length","formatEntryPaths","entry","Array","push","map","endsWith","replace","filter","formatSpecPaths","paths","forEach","match","warn","red","cyan"],"mappings":"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","file":"paths.js","sourcesContent":["/* eslint max-len:0, no-useless-escape:0 */\r\n\r\nimport R from 'ramda';\r\nimport fs from 'fs-extra';\r\nimport fsPath from 'path';\r\nimport chalk from 'chalk';\r\nimport log from '../shared/log';\r\n\r\n\r\n\r\n/**\r\n * Retrieves the absolute path to the root module, which will be either:\r\n *   - the referencing parent module (typically)\r\n *   - or the ui-harness itself (when under development).\r\n *\r\n * @return {String}.\r\n */\r\nexport const rootModulePath = () => {\r\n  const parent = fsPath.resolve('../');\r\n  return fsPath.basename(parent) === 'node_modules'\r\n    ? fsPath.resolve('../../')\r\n    : fsPath.resolve('./');\r\n};\r\nconst ROOT_PATH = rootModulePath();\r\n\r\n\r\n\r\n/**\r\n * Walks up the folder hierarchy looking for the closest module.\r\n * @param {String} moduleDir: The path to the module directory\r\n *                            (ie. the parent of node_modules).\r\n * @param {String} moduleName: The name of the module you are looking for.\r\n *\r\n * @return {String}.\r\n */\r\nexport const closestModulePath = (moduleDir, moduleName) => {\r\n  const dir = fsPath.join(moduleDir, 'node_modules', moduleName);\r\n  if (fs.existsSync(dir)) {\r\n    return dir;\r\n  }\r\n  // Not found, walk up the folder-hierarhcy.\r\n  const parent = fsPath.resolve(moduleDir, '..');\r\n  if (parent !== fsPath.resolve('/')) {\r\n    return closestModulePath(parent, moduleName); // <== RECURSION.\r\n  }\r\n  return undefined;\r\n};\r\n\r\n\r\n/**\r\n *  Retrieve the path to the `react` module.\r\n *\r\n *   - First look within the UIHarness module, as that will be the\r\n *     latest version supported by UIHarness, and will be here if another reference\r\n *     has caused a different version of react to be held in the root node_modules.\r\n *\r\n *   - If not found locally, then walk up the tree to find the first reference of it.\r\n */\r\nexport const REACT_PATH = closestModulePath(fsPath.join(__dirname, '../../'), 'react');\r\n\r\n\r\n\r\n/**\r\n * Trims the root module path from the given path (if it exists).\r\n * @param {String} path: The path to modify.\r\n * @return {String}.\r\n */\r\nexport const trimRootModulePath = (path) => {\r\n  if (!R.is(String, path)) { return path; }\r\n  return path.startsWith(ROOT_PATH)\r\n            ? `.${ path.substr(ROOT_PATH.length, path.length) }`\r\n            : path;\r\n};\r\n\r\n\r\n\r\n/**\r\n * Prepare entry paths for the WebPack bundle.\r\n *\r\n * @param {String|Array} entry: Paths to entry points of files to pass\r\n *                              to WebPack to build for the client.\r\n *\r\n * @return {Object} of paths.\r\n */\r\nexport const formatEntryPaths = (entry) => {\r\n  entry = entry || [];\r\n  if (!R.is(Array, entry)) { entry = [entry]; }\r\n  if (entry.length === 0) {\r\n    entry.push('./specs');\r\n    entry.push('./src/specs');\r\n  }\r\n  return entry\r\n    // Ensure there is a specific index.js entry file if only a folder was given.\r\n    // NB: Not having a specific entry file can cause build-errors in WebPack.\r\n    .map(path => (path.endsWith('.js') || path.endsWith('.jsx')\r\n        ? path\r\n        : `${ path }/index.js`))\r\n\r\n    // Escape white-spaces within paths.\r\n    .map(path => path.replace(/ /, '\\ '))\r\n\r\n    // Resolve relative (.) paths into fully-qualified paths.\r\n    .map(path => (path.startsWith('.') ? fsPath.resolve(path) : path))\r\n\r\n    // Remove any paths that don't actually exist.\r\n    .filter(path => fs.existsSync(path));\r\n};\r\n\r\n\r\n\r\n\r\n\r\n/**\r\n * Prepare spec paths for the WebPack bundle.\r\n *\r\n * @param {String|Array} entry: Paths to entry points of files to pass\r\n *                              to WebPack to build for the client.\r\n *\r\n * @return {Object} of paths.\r\n */\r\nexport const formatSpecPaths = (entry) => {\r\n  const paths = formatEntryPaths(entry);\r\n\r\n  // Check for non-standard characters within the paths.\r\n  paths.forEach(path => {\r\n    if (!path.match(/^[a-z0-9\\.\\-\\_\\s\\/]+$/i)) {\r\n      log.warn(chalk.red('WARNING Path contains non-standard characters. Auto-reloading may not work.'));\r\n      log.warn(chalk.red('        Hint: Brackets in the path \"(...)\" will cause problems.'));\r\n      log.warn(chalk.cyan(`        ${ path }`));\r\n      log.warn('');\r\n    }\r\n  });\r\n\r\n  // Finish up.\r\n  return paths;\r\n};\r\n"]}